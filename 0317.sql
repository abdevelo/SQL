SELECT ENAME
FROM EMP
WHERE DEPTNO = 20;

SELECT ENAME
	, JOB
	, SAL
	, DEPTNO  
FROM EMP
WHERE DEPTNO = 20
 AND JOB = 'CLERK';
 
-- 등호, 부등호

SELECT * FROM EMP WHERE SAL = 5000;

SELECT * FROM EMP WHERE SAL != 5000;

SELECT * FROM EMP WHERE SAL <> 5000;

SELECT * FROM EMP WHERE SAL ^= 5000;

SELECT * FROM EMP WHERE NOT SAL = 5000;

SELECT * FROM EMP 
WHERE SAL = (SELECT MAX(SAL) FROM EMP);
-- AND,OR조건

SELECT * FROM EMP WHERE SAL = 5000 AND SAL = 3000;

SELECT * FROM EMP WHERE SAL = 5000 OR SAL = 3000;

-- LIKE 연산자 ( ONE OF WILD CARD)

SELECT * FROM EMP
WHERE ENAME LIKE 'M%';

SELECT * FROM EMP
WHERE ENAME LIKE '_L%';

SELECT * FROM EMP
WHERE ENAME LIKE '%AM%';

-- NULL값에 대한 이해

SELECT * FROM EMP WHERE COMM = NULL; -- =는 ALLOCATE 이지 Equal이 아니다.
SELECT * FROM EMP WHERE COMM IS NULL; 
SELECT * FROM EMP WHERE MGR = NULL; -- 는 에러가 안나옴...
SELECT * FROM EMP WHERE 1 <> 1; -- EMPTY ?
SELECT * FROM EMP WHERE MGR IS NULL; 

SELECT EMPNO
	, ENAME
	, SAL
	, DEPTNO 
	,JOB 
FROM EMP
WHERE JOB = 'CLERK'
UNION 
SELECT EMPNO
	, ENAME
	, SAL
	, DEPTNO 
	, JOB
FROM EMP
WHERE JOB = 'SALESMAN';


SELECT EMPNO 
	, ENAME 
	, SAL
	, DEPTNO
FROM EMP
WHERE DEPTNO  = 10
UNION 
SELECT EMPNO
	, ENAME
	, SAL
FROM EMP
WHERE DEPTNO  = 20; -- 컬럼 수가 달라 오류 

-- UION ALL

SELECT EMPNO 
	, ENAME 
	, SAL
	, DEPTNO
FROM EMP
WHERE DEPTNO  = 10
UNION 
SELECT EMPNO 
	, ENAME 
	, SAL
	, DEPTNO
FROM EMP
WHERE DEPTNO  = 10;


-- MINUS INTERSECT 


SELECT EMPNO 
	, ENAME 
	, SAL
	, DEPTNO
FROM EMP
MINUS 
SELECT EMPNO 
	, ENAME 
	, SAL
	, DEPTNO
FROM EMP
WHERE DEPTNO  = 10;


-- 오라클 함수 

SELECT * FROM V$sqlfn_metadata;

SELECT func_id,argnum,datatype FROM V$sqlfn_arg_metadata;

SELECT * FROM v$sqlfn_metadata
WHERE datatype = 'STRING';

-- 문자열 함수

SELECT * FROM EMP
WHERE UPPER(ENAME) = UPPER('scott');

SELECT ENAME 
	, LENGTH(ENAME) AS "LENGTH_ENAME"
FROM EMP
WHERE LENGTH (ENAME) >= 5;


-- SUBSTR

SELECT JOB
	, SUBSTR(JOB,1,2), SUBSTR(JOB,3,2), SUBSTR(JOB,5)
FROM EMP;

SELECT JOB
	, SUBSTR(JOB,-LENGTH(JOB))
	, SUBSTR(JOB, -LENGTH(JOB),2)
	, SUBSTR(JOB,-3)
FROM EMP;

-- REPLACE

SELECT '010-1234-5678' AS REPLACE_BEFORE
	,REPLACE ('010-1234-5678','-',' ') AS REPLACE_1 --공백도 그대로 대체
	,REPLACE ('010-1234-5678','-') AS REPLACE_2
FROM DUAL;

-- LAPD

SELECT 'Oracle', LPAD('Oracle',10,'#') AS LPAD_1
	,RPAD('Oracle',10,'*') AS RPAD_1
	,LPAD('Oracle',10) AS LPAD_2
	,RPAD('Oracle',10) AS LPAD_2
FROM DUAL;

-- RPAD
SELECT RPAD('971225-',14,'*') AS PRAD_JMNO
	,RPAD('010-1234-',13,'*') AS RPAD_PHONE
FROM DUAL;


-- CEIL


-- ABS

SELECT ABS(-100),ABS(100),ABS(0)
FROM DUAL;

-- SIGN
SELECT SIGN(-100), SIGN(100), SIGN(0)
FROM DUAL;


-- DATE	
SELECT SYSDATE AS NOW
	,SYSDATE-1 AS YESTERDAY
	,SYSDATE+1 AS TOMMOROW
FROM DUAL;

SELECT SYSDATE, ADD_MONTHS(SYSDATE,3)
FROM DUAL;

SELECT EMPNO, ENAME, HIREDATE,
	ADD_MONTHS(HIREDATE, 12*20) AS WORK10YEAR
FROM EMP; -- 입사일로부터 20년을 더한 일자

SELECT EMPNO, ENAME, HIREDATE , SYSDATE
FROM EMP
WHERE ADD_MONTHS(HIREDATE,12*40) > SYSDATE ; -- 입사 40년 근속 직원


SELECT ENAME, HIREDATE, SYSDATE 
	, MONTHS_BETWEEN(HIREDATE,SYSDATE)/12 AS Year1,
	, MONTHS_BETWEEN(SYSDATE,HIREDATE))/12 AS Year2,
	, TRUNC(MONTHS_BETWEEN(SYSDATE,HIREDATE)/12) AS Year3
FROM EMP;

SELECT SYSDATE,
	NEXT_DAY(SYSDATE,'monday'), -- 다음 'monday'
	LAST_DAY(SYSDATE) -- 이번달 마지막날
FROM DUAL; 

SELECT ENAME 
	,EXTRACT (YEAR FROM HIREDATE) AS y
	,EXTRACT (MONTH FROM HIREDATE) AS m
	,EXTRACT (DAY FROM HIREDATE) AS d
FROM emp;


-- Inner-join 

SELECT * 
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMPNO;

-- JOIN ~ ON 

SELECT * 
FROM EMP E JOIN DEPT D 
		ON (E.DEPTNO = D.DEPTNO)
ORDER BY EMPNO;

-- USING (굳이 안써도)

SELECT *
FROM EMP E JOIN DEPT D 
		USING (DEPTNO)
ORDER BY E.EMPNO ;

-- 컬럼명이 구분되지 않는 경우 

SELECT EMPNO
	, ENAME
	, DEPTNO -- 중복되는 칼럼으로 별칭이 필요
	, DNAME
	, LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO ;

-- JOIN에 WHERE 조건식 추가 

